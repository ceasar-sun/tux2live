#!/bin/sh

####################################################
# tux2live system builder
#
# Description: To build root filesystem for live system , part 2 of tux2live
# Last update :
# Author:
#	Ceasar Sun <ceasar_at_nchc_org_tw>
#	
# License: GPL
####################################################
####################
# Sub function
####################

mkrootfs(){
	local _rsync_opt=$_RSYNC_OPT_EXTRA
	[ ! -d "$_LIVE_ROOT_PATH" ] && mkdir $_LIVE_ROOT_PATH && echo "Create squash root fs :$_LIVE_ROOT_PATH ..."
	echo -e "Build root filesystem ..."

	echo -e "\tcreate empty dirs: $_CREAT_EMPTY_DIR ..."
	for i in $_CREAT_EMPTY_DIR ; do
		[ -d "$_LIVE_ROOT_PATH/$i" ] && rm -rf $_LIVE_ROOT_PATH/$i >/dev/null 2>&1
		mkdir -p $_LIVE_ROOT_PATH/$i
	done
 
	echo -e "\tchmod special dirs ..."
	for chmdir in $_MKROOTFS_CHMOD_DIR; do
		dirn=$(echo ${chmdir} | cut -d ':' -f 1)
		dirp=$(echo ${chmdir} | cut -d ':' -f 2)
		chmod -f $dirp $_LIVE_ROOT_PATH/$dirn
	done
	
	for j in $_NO_SYNC_PATH ; do
		_rsync_opt="$_rsync_opt --exclude=$j"
	done
	_rsync_opt="$_rsync_opt --exclude=$_TUX2LIVE_ROOT_DIR --exclude=$_TUX2LIVE_OUTPUT_DIR --exclude=$_TUX2LIVE_TMP_DIR"

	echo -e "\tsync file system, it would maybe take a long ...long time ..."

	for syncdir in $_ROOT_PATH ; do
		_root_path="$(echo $syncdir | cut -d ':' -f 1)"
		_live_path="$(echo $syncdir | cut -d ':' -f 2)"
		_junk="$(echo $syncdir | cut -d ':' -f 3)"
		[ -z "$_root_path" -o -z "$_live_path" -o -n "$_junk" ] && echo "Skip sync path: '$syncdir'"&& continue
		[ -d "${_LIVE_ROOT_PATH}${_live_path}" ] || mkdir -p "${_LIVE_ROOT_PATH}${_live_path}"
		_comm_line="$_RSYNC_COMM $_VERBOSE $_rsync_opt ${_root_path}/ ${_LIVE_ROOT_PATH}${_live_path}/"
		[ "$_DEBUG" == "y" ] && DEBUG_MESSAGE "$_comm_line"
		$_comm_line
		WAIT_UNTIL_COMM $_comm_line
	done
	echo "done"

	if [ "$_DRBL_MODE" = "y" ]; then
		echo -n "Recover necessary services from real root: "
		for si in $_MKROOTFS_SERVICE_TO_RECOVER; do
			if [ -f "/etc/init.d/$si" ]; then
				echo -n "$si... "
				cp -f $_VERBOSE /etc/init.d/$si ${_LIVE_ROOT_PATH}/etc/init.d/
				for sfile in `ls /etc/rc[123456].d/S[0-9][0-9]$si 2>/dev/null`; do
					cp $_VERBOSE $sfile ${_LIVE_ROOT_PATH}${sfile}
				done
			fi
		done
		echo "done"
	fi

}

run_parts(){

	echo "Run post-scripts ..."
	run_parts_dir=

	if [ -e /etc/debian_version ]; then
	# Debian
		MINUID="1000"
		run_parts_dir=$_TUX2LIVE_ROOT_DIR/function/4_debian
	elif [ -e /etc/SuSE-release ]; then
	# Suse
		MINUID="1000"
		run_parts_dir=$_TUX2LIVE_ROOT_DIR/function/4_suse
	else 
	# RH-like
		MINUID="500"
		run_parts_dir=$_TUX2LIVE_ROOT_DIR/function/4_rh
	fi	
	# use $MINUID as new uid to avoid it alrady be used in original system, like EzGo7, uses 999 uid to ezgo7 account 
	_LIVECD_USERUID=$MINUID

	
	# The purpose of this session is to get the groups from user account 
	#  if no assigned user, use the first user in os
	[ -z "$_MKROOTFS_IMPORT_USER" ] && _tmp_get_groups_by_user="$(awk -F":" "\$3 == $MINUID {print \$1}" /etc/passwd)" || _tmp_get_groups_by_user=$_MKROOTFS_IMPORT_USER
	[ -z "$_MKROOTFS_IMPORT_USER_GROUPS" ] && _MKROOTFS_IMPORT_USER_GROUPS=$(echo " `groups $_tmp_get_groups_by_user` " | sed -e "s/\ $_tmp_get_groups_by_user\ //g" -e "s/://g" -e "s/^\s//g" -e "s/\s$//g")

	if [ -d "$run_parts_dir" ]; then
		# Prepare 
		cat > $_LIVE_ROOT_PATH/etc/tux2live.conf << EOF
# This file is auto generated by tux2live mkrootfs

_TUX2LIVE_VERSION="$_TUX2LIVE_VERSION"

_LIVECD_HOSTNAME="$_LIVECD_HOSTNAME"
_LIVECD_USERNAME="$_LIVECD_USERNAME"
_LIVECD_USERUID="$_LIVECD_USERUID"
_LIVECD_PASSWD="$_LIVECD_PASSWD"
_LIVECD_GROUPS="$_MKROOTFS_IMPORT_USER_GROUPS $_MKROOTFS_IMPORT_USER_GROUPS_EXT" 
_LIVECD_ROOTFS_METHOD="$_TUX2LIVE_ROOTFS_METHOD"

_SERVICES_TO_STOP="$_SERVICES_TO_STOP"
_PACKAGE_TO_POSTREMOVE="$_MKROOTFS_PACKAGE_TO_POSTREMOVE"

EOF
		echo -n "Use ";$SETCOLOR_WARNING; echo -n "$(basename $run_parts_dir)"; $SETCOLOR_NORMAL; echo " post-scripts ..."

		# Parepare post-scripts pool
		cp -a $run_parts_dir/S* $_LIVE_ROOT_PATH/tmp/
		chmod +x $_LIVE_ROOT_PATH/tmp/S*
		cp -a $run_parts_dir/_scripts $_LIVE_ROOT_PATH/tmp/

		# rebind /dev nad /proc into $_LIVE_ROOT_PATH/dev|/proc.
		#  It's important for run postrun environemnt, ex: perl
		mount -o rbind /dev $_LIVE_ROOT_PATH/dev
		mount -o rbind /proc $_LIVE_ROOT_PATH/proc

		for _script_id in `ls $run_parts_dir/S*`; do
			if [ -f "$_script_id" ]; then
				_run_name="$(basename $_script_id)"
				[ "$_DEBUG" == "y" ] && echo -e "\tchroot $_LIVE_ROOT_PATH	/tmp/$_run_name"
				chroot $_LIVE_ROOT_PATH	/tmp/$_run_name
			fi
		done

		# umount $_LIVE_ROOT_PATH/dev
		umount -l $_LIVE_ROOT_PATH/proc
		umount -l $_LIVE_ROOT_PATH/dev

		rm -rf $_LIVE_ROOT_PATH/tmp/*
	fi
}

import_user_home(){
	
	echo "Import runtime environment for '$_TUX2LIVE_LIVECD_USERNAME' user..."
	
	if [ -e "/etc/debian_version" ]; then
		MINUID="1000"
	elif [ -e "/etc/SuSE-release" ]; then
		MINUID="1000"
	else 
		MINUID="500"
	fi 
	
	user_lists="$(awk -F":" "\$3 >= $MINUID && \$1 != \"nobody\" {print \$1}" /etc/passwd)"
	# set which account to import
	if [ "$_BATCH_MODE" = 'y' -o -n "$_MKROOTFS_IMPORT_USER" ]; then
		[ -z "$_MKROOTFS_IMPORT_USER" ] && _MKROOTFS_IMPORT_USER="$(awk -F":" "\$3 == $MINUID {print \$1}" /etc/passwd)"
	elif [ -n "$user_lists" ]; then
		echo "Please select which user data would be imported for live  CD mode ? "
		echo "*** Note *** Make sure it dosen't inclue confidentiality or private data !!!"

		declare i=1 j=1
		for un in $user_lists; do
			echo "[$i] $un"
			declare lid[i++]="$i"; lname[j++]="$un";
		done
		read -p "Select a number , 0 for skipp this [0] :" _answer
		[ -z "$_answer" ] && _answer=0 && echo "skip !!" && return
		_MKROOTFS_IMPORT_USER=${lname[$_answer]}
	else
		echo "No normal user to import , skip !!!"
	fi
	_user_home=$(grep -E "^$_MKROOTFS_IMPORT_USER\:" /etc/passwd | cut -d ':' -f 6)
	[ ! -d "$_user_home" ] && "No user home fo import: '[$_MKROOTFS_IMPORT_USER]:$_user_home' " && return ;
	echo "Star to import user data : '[$_MKROOTFS_IMPORT_USER]:$_user_home' -> [$_LIVECD_USERNAME]:$_LIVE_ROOT_PATH/home/$_LIVECD_USERNAME/'"
	# sync user data
	_comm_line="$__RSYNC_COMM $_VERBOSE $_RSYNC_OPT_EXTRA --exclude=${_TUX2LIVE_ROOT_DIR#$_user_home/} --exclude=${_TUX2LIVE_OUTPUT_DIR#$_user_home/} --exclude=${_TUX2LIVE_TMP_DIR#$_user_home/} --exclude=.gvfs --exclude=.local/share/gvfs*  $_user_home/ $_LIVE_ROOT_PATH/home/$_LIVECD_USERNAME/"
	[ "$_DEBUG" == "y" ] && DEBUG_MESSAGE "$_comm_line"
	$_comm_line

	# make a symbolic link to match imported user home
	[ "$_MKROOTFS_IMPORT_USER" != "$_LIVECD_USERNAME" ] && ln -s $_LIVECD_USERNAME $_LIVE_ROOT_PATH/home/$_MKROOTFS_IMPORT_USER && echo "Make a  symbolic link '/home/$_MKROOTFS_IMPORT_USER' to '/home/$_LIVECD_USERNAME/'"

	# chown as livecd.livecd for live environemnt
	_comm_line="chroot $_LIVE_ROOT_PATH chown -R $_LIVECD_USERNAME.$_LIVECD_USERNAME /home/$_LIVECD_USERNAME/"
	[ "$_DEBUG" = "-v" ] && DEBUG_MESSAGE "$_comm_line"
	$_comm_line
}

mkrootimg(){

	# -n "$(grep -i -e  '^fedora' /etc/issue 2> /dev/null)" ##For Fedora Core series
	# -n "$(grep -i -e  '^centos' /etc/issue 2> /dev/null)" ## For CentOS series
	# -n "$(grep -i -e  '^Red Hat Enterprise' /etc/issue 2> /dev/null)" ##For RHEL series
	# -n "$(echo $_TUX2LIVE_ENV_CHECK_STACKS |grep 'm:unionfs' 2> /dev/null)" ##Actually, it should includes all above 
	if [ "$_TUX2LIVE_ROOTFS_METHOD" = "dm_snapshot" ] ; then
			$SETCOLOR_WARNING; echo "Use dm_snapshot method ..."; $SETCOLOR_NORMAL

			[ -d "$_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP" ] || mkdir -p $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP
			[ -d "$_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS" ] && echo "Clean old squashfs folder: '$_MKROOTFS_OSIMG_SQFS'" && rm -rf $_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS
			mkdir -p $_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS/sysroot

			img_size=$(du -shx -B M $_LIVE_ROOT_PATH | awk '{print $1}'| sed -s -e "s/M//g")
			img_size=$(expr ${img_size} \* 7 / 5 )	# add 40% of all as total space

			echo "Create os image :'$_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_NAME' with '$img_size' MB space "
			_comm_line="dd if=/dev/null of=${_TUX2LIVE_TMP_DIR}/${_MKROOTFS_OSIMG_NAME} bs=1M count=1 seek=${img_size} "
			[ "$_DEBUG" == "y" ] && DEBUG_MESSAGE "$_comm_line"
			$_comm_line
			mkfs.$_MKROOTFS_OSIMG_FSTYPE -F $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_NAME
			[ -d "$_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP " ] || mkdir -p $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP 
			mount -t $_MKROOTFS_OSIMG_FSTYPE -o loop $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_NAME $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP

			$SETCOLOR_WARNING; echo "Copy root filesystem into $_MKROOTFS_OSIMG_FSTYPE image file:'$_LIVE_ROOT_PATH/'->'$_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP/'. It would maybe take a long time ..."; $SETCOLOR_NORMAL
			_comm_line="$_RSYNC_COMM $_VERBOSE -a $_LIVE_ROOT_PATH/ $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP/"
			[ "$_DEBUG" == "y" ] && DEBUG_MESSAGE "$_comm_line"
			$_comm_line
			WAIT_UNTIL_COMM $_comm_line
			umount $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP
			mv $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_NAME $_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS/
			rm -rf $_TUX2LIVE_TMP_DIR/$_MKROOTFS_OSIMG_LOOP
			echo "Check stuff:" $(ls $_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS/)
			[ "$_PURGE" = "y" ] && (echo "Clean tmp root filesystem :'$_LIVE_ROOT_PATH'" ; rm -rf $_LIVE_ROOT_PATH)

			_LIVE_ROOT_PATH=$_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS
	fi

	$SETCOLOR_WARNING; echo "Start to make root squashfs :'$_LIVE_ROOT_PATH/'->'$_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS'. It would maybe take a long time ..."; $SETCOLOR_NORMAL
	[ -f "$_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS" ] && rm -rf $_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS;
	#_comm_line="$_MKSQUASHFS_COMM $_LIVE_ROOT_PATH/* $_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS $_MKSQUASHFS_PARA"
	_comm_line="$_MKSQUASHFS_COMM $_LIVE_ROOT_PATH/ $_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS $_MKSQUASHFS_PARA"
	[ "$_DEBUG" == "y" ] && DEBUG_MESSAGE "$_comm_line"
	$_comm_line
	WAIT_UNTIL_COMM $_comm_line
	[ -d "$_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS" ] && echo "Remove tmp folder:'$_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS'" && rm -rf $_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_OSIMG_SQFS
	echo "done"
	
}

tux2mkrootfs () {
	# Load Tux2live setting and functions
	[ -f "$_TUX2LIVE_ROOT_DIR/conf/tux2live.conf" ] && [ -z "$_LOAD_TUX2LIVE_CONF" ] && . $_TUX2LIVE_ROOT_DIR/conf/tux2live.conf

	_ROOT_PATH="$_MKROOTFS_ROOT_PATH $_CUSTOM_MKROOTFS_ROOT_PATH"

	_LIVE_ROOT_PATH=$_TUX2LIVE_OUTPUT_DIR/$_MKROOTFS_LIVE_ROOT_DIR

	_MKSQUASHFS_COMM=$__MKSQUASHFS_COMM
	_MKSQUASHFS_PKG=$_MKROOTFS_MKSQUASHFS_PKG
	_MKSQUASHFS_PARA=$_MKROOTFS_MKSQUASHFS_PARA

	_RSYNC_COMM=$__RSYNC_COMM
	_RSYNC_PKG=$_MKROOTFS_RSYNC_PKG
	_RSYNC_OPT_EXTRA=$_MKROOTFS_RSYNC_OPT_EXTRA

	_CREAT_EMPTY_DIR=$_MKROOTFS_CREAT_EMPTY_DIR
	_NO_SYNC_PATH="$_MKROOTFS_CREAT_EMPTY_DIR $_MKROOTFS_NO_SYNC_PATH"
	_SERVICES_TO_STOP="$_MKROOTFS_SERVICE_TO_STOP"

	_LIVECD_HOSTNAME=$_TUX2LIVE_LIVECD_HOSTNAME
	_LIVECD_USERNAME=$_TUX2LIVE_LIVECD_USERNAME
	_LIVECD_USERUID=$_TUX2LIVE_LIVECD_USERUID
	_LIVECD_PASSWD=$_TUX2LIVE_LIVECD_PASSWD

	local _answer;

	# Main
	echo "Tux2live root filesystem path: $_LIVE_ROOT_PATH"
	[ "$_BATCH_MODE" = 'n' ] && ($SETCOLOR_WARNING; echo -n "Start to creat root squashfs ? [Y/n]"; $SETCOLOR_NORMAL; read _answer) || ( $SETCOLOR_WARNING; echo "**** Start to creat root squashfs ****"; $SETCOLOR_NORMAL )
	[ "$_answer" = "n" ] && echo "Bye !!" && exit 1;

	# clean up old squashfs rootfs 
	[ -f "$_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS" ] && echo "Clean up old iso squashfs : $_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS ..." && rm -rf $_TUX2LIVE_OUTPUT_DIR/$_TUX2LIVE_ISO_SQUASHFS

	mkrootfs

	# Do reconfig, add user, stop services, clean files ...  
	run_parts

	# Program doesn't import user data when it's in batch mode and it doesn't be assigned any user account 
	[ "$_BATCH_MODE" = 'y' -a -z "$_MKROOTFS_IMPORT_USER" ] || import_user_home

	mkrootimg

	[ "$PURGE" = "y" ] && (echo "Clean tmp root filesystem :'$_LIVE_ROOT_PATH'" ; rm -rf $_LIVE_ROOT_PATH)

	return 0;
}

